use crate::crystal_viewer::CrystalStructure;
use std::fs::File;
use std::io::Write;
use anyhow::{Result, Context};

/// Trait for structure exporters
pub trait StructureExporter {
    fn export(&self, structure: &CrystalStructure) -> Result<String>;
    fn extension(&self) -> &str;
    fn description(&self) -> &str;
}

/// CIF Exporter (Crystallographic Information File)
pub struct CifExporter;

impl StructureExporter for CifExporter {
    fn extension(&self) -> &str { "cif" }
    fn description(&self) -> &str { "Crystallographic Information File (*.cif)" }

    fn export(&self, structure: &CrystalStructure) -> Result<String> {
        let mut content = String::new();
        
        // Header
        content.push_str("data_crystal\n");
        content.push_str("_audit_creation_method 'Crystal MCP Generator'\n");
        
        // Lattice
        let a = structure.lattice.a;
        let b = structure.lattice.b;
        let c = structure.lattice.c;
        let alpha = structure.lattice.alpha;
        let beta = structure.lattice.beta;
        let gamma = structure.lattice.gamma;
        
        content.push_str(&format!("_cell_length_a {:.6}\n", a));
        content.push_str(&format!("_cell_length_b {:.6}\n", b));
        content.push_str(&format!("_cell_length_c {:.6}\n", c));
        content.push_str(&format!("_cell_angle_alpha {:.6}\n", alpha));
        content.push_str(&format!("_cell_angle_beta {:.6}\n", beta));
        content.push_str(&format!("_cell_angle_gamma {:.6}\n", gamma));
        
        // Volume if available
        if let Some(vol) = structure.lattice.volume {
            content.push_str(&format!("_cell_volume {:.6}\n", vol));
        }
        
        // Space group
        content.push_str("_symmetry_space_group_name_H-M 'P 1'\n");
        content.push_str("_symmetry_Int_Tables_number 1\n");
        content.push_str("loop_\n_symmetry_equiv_pos_as_xyz\n'x, y, z'\n");
        
        // Atoms
        content.push_str("\nloop_\n");
        content.push_str("_atom_site_label\n");
        content.push_str("_atom_site_type_symbol\n");
        content.push_str("_atom_site_fract_x\n");
        content.push_str("_atom_site_fract_y\n");
        content.push_str("_atom_site_fract_z\n");
        
        let atoms = structure.atoms.as_slice();
        let atoms = if atoms.is_empty() {
             structure.sites.as_deref().unwrap_or(&[])
        } else {
             atoms
        };

        for (i, atom) in atoms.iter().enumerate() {
            // Use coords (fractional) if available, otherwise convert cartesian
            // For now assuming coords are fractional as per Schema
            let x = atom.coords[0];
            let y = atom.coords[1];
            let z = atom.coords[2];
            
            content.push_str(&format!(
                "{}{} {} {:.6} {:.6} {:.6}\n",
                atom.element, i+1, atom.element, x, y, z
            ));
        }
        
        Ok(content)
    }
}

/// XYZ Exporter (Cartesian coordinates)
pub struct XyzExporter;

impl StructureExporter for XyzExporter {
    fn extension(&self) -> &str { "xyz" }
    fn description(&self) -> &str { "XYZ Cartesian Format (*.xyz)" }

    fn export(&self, structure: &CrystalStructure) -> Result<String> {
        let mut content = String::new();
        
        let atoms = structure.atoms.as_slice();
        let atoms = if atoms.is_empty() {
             structure.sites.as_deref().unwrap_or(&[])
        } else {
             atoms
        };
        
        // Number of atoms
        content.push_str(&format!("{}\n", atoms.len()));
        
        // Comment line (Title/Formula)
        let formula = structure.metadata.as_ref()
            .and_then(|m| m.formula.clone())
            .unwrap_or_else(|| "Generated Structure".to_string());
        content.push_str(&format!("{}\n", formula));
        
        // Atoms
        for atom in atoms {
            let x = atom.cartesian[0];
            let y = atom.cartesian[1];
            let z = atom.cartesian[2];
            content.push_str(&format!(
                "{:<2} {:12.6} {:12.6} {:12.6}\n",
                atom.element, x, y, z
            ));
        }
        
        Ok(content)
    }
}

/// POSCAR Exporter (VASP Format)
pub struct PoscarExporter;

impl StructureExporter for PoscarExporter {
    fn extension(&self) -> &str { "vasp" }
    fn description(&self) -> &str { "VASP POSCAR (*.vasp)" }

    fn export(&self, structure: &CrystalStructure) -> Result<String> {
        let mut content = String::new();
        
        // Comment
        content.push_str("Generated by Crystal MCP\n");
        // Scaling factor
        content.push_str("1.0\n");
        
        // Lattice vectors
        if let Some(matrix) = &structure.lattice.matrix {
            for row in matrix {
                content.push_str(&format!(" {:12.6} {:12.6} {:12.6}\n", row[0], row[1], row[2]));
            }
        } else {
            // Basic cubic fallback if no matrix
            let a = structure.lattice.a;
            let b = structure.lattice.b;
            let c = structure.lattice.c;
            content.push_str(&format!(" {:12.6} 0.000000 0.000000\n", a));
            content.push_str(&format!(" 0.000000 {:12.6} 0.000000\n", b));
            content.push_str(&format!(" 0.000000 0.000000 {:12.6}\n", c));
        }
        
        // Count elements
        let atoms = structure.atoms.as_slice();
        let atoms = if atoms.is_empty() {
             structure.sites.as_deref().unwrap_or(&[])
        } else {
             atoms
        };
        
        // Group by element to match POSCAR format requirements
        let mut elements: Vec<String> = Vec::new();
        let mut counts: Vec<usize> = Vec::new();
        
        // Need to sort atoms by element first to group them
        let mut sorted_atoms = atoms.to_vec();
        sorted_atoms.sort_by(|a, b| a.element.cmp(&b.element));
        
        if !sorted_atoms.is_empty() {
            let mut current_el = sorted_atoms[0].element.clone();
            let mut current_count = 0;
            
            for atom in &sorted_atoms {
                if atom.element != current_el {
                    elements.push(current_el);
                    counts.push(current_count);
                    current_el = atom.element.clone();
                    current_count = 0;
                }
                current_count += 1;
            }
            elements.push(current_el);
            counts.push(current_count);
        }
        
        // Element symbols
        content.push_str(&format!(" {}\n", elements.join(" ")));
        // Counts
        content.push_str(&format!(" {}\n", counts.iter().map(|c| c.to_string()).collect::<Vec<_>>().join(" ")));
        
        // Direct coordinates
        content.push_str("Direct\n");
        for atom in sorted_atoms {
            content.push_str(&format!(
                " {:10.6} {:10.6} {:10.6}\n",
                atom.coords[0], atom.coords[1], atom.coords[2]
            ));
        }
        
        Ok(content)
    }
}

/// JSON Exporter (Raw Data)
pub struct JsonExporter;

impl StructureExporter for JsonExporter {
    fn extension(&self) -> &str { "json" }
    fn description(&self) -> &str { "JSON Data (*.json)" }

    fn export(&self, structure: &CrystalStructure) -> Result<String> {
        serde_json::to_string_pretty(structure).context("Failed to serialize structure to JSON")
    }
}

pub fn save_structure(structure: &CrystalStructure, path: &str, format: &str) -> Result<()> {
    let exporter: Box<dyn StructureExporter> = match format {
        "cif" => Box::new(CifExporter),
        "xyz" => Box::new(XyzExporter),
        "vasp" | "poscar" => Box::new(PoscarExporter),
        "json" => Box::new(JsonExporter),
        _ => return Err(anyhow::anyhow!("Unsupported format: {}", format)),
    };
    
    let content = exporter.export(structure)?;
    let mut file = File::create(path)?;
    file.write_all(content.as_bytes())?;
    
    Ok(())
}
