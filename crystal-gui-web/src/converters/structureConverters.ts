/**
 * Structure Converters - Convert MCP output to viewer formats
 * 
 * Converts structure data from Python backend JSON to formats 
 * suitable for MolStar (CIF, PDB) and Kekule.js (Mol2, SMILES)
 */

import type { StructureData, AtomData } from '../types';

/**
 * Convert MCP structure to CIF format for MolStar
 */
export function structureToCif(structure: StructureData): string {
    const lines: string[] = [];
    const formula = structure.metadata?.formula || 'Unknown';

    // CIF header
    lines.push(`data_${formula.replace(/\s/g, '_')}`);
    lines.push(`_chemical_formula_structural '${formula}'`);
    lines.push(`_cell_length_a ${structure.lattice.a.toFixed(4)}`);
    lines.push(`_cell_length_b ${structure.lattice.b.toFixed(4)}`);
    lines.push(`_cell_length_c ${structure.lattice.c.toFixed(4)}`);
    lines.push(`_cell_angle_alpha ${structure.lattice.alpha.toFixed(2)}`);
    lines.push(`_cell_angle_beta ${structure.lattice.beta.toFixed(2)}`);
    lines.push(`_cell_angle_gamma ${structure.lattice.gamma.toFixed(2)}`);

    // Space group
    if (structure.space_group) {
        lines.push(`_symmetry_space_group_name_H-M '${structure.space_group.symbol}'`);
        lines.push(`_symmetry_Int_Tables_number ${structure.space_group.number}`);
    } else {
        lines.push(`_symmetry_space_group_name_H-M 'P1'`);
        lines.push(`_symmetry_Int_Tables_number 1`);
    }

    // Atom loop
    lines.push('');
    lines.push('loop_');
    lines.push('_atom_site_label');
    lines.push('_atom_site_type_symbol');
    lines.push('_atom_site_fract_x');
    lines.push('_atom_site_fract_y');
    lines.push('_atom_site_fract_z');

    structure.atoms.forEach((atom, i) => {
        const label = `${atom.element}${i + 1}`;
        const [x, y, z] = atom.coords;
        lines.push(`${label} ${atom.element} ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}`);
    });

    return lines.join('\n');
}

/**
 * Convert MCP structure to PDB format
 */
export function structureToPdb(structure: StructureData): string {
    const lines: string[] = [];
    const formula = structure.metadata?.formula || 'MOL';

    // Header
    lines.push(`HEADER    ${formula.padEnd(40)} ${new Date().toISOString().slice(0, 10)}`);
    lines.push(`TITLE     Generated by Crystal GUI`);

    // Crystal unit cell (if applicable)
    const lat = structure.lattice;
    lines.push(
        `CRYST1${lat.a.toFixed(3).padStart(9)}${lat.b.toFixed(3).padStart(9)}${lat.c.toFixed(3).padStart(9)}` +
        `${lat.alpha.toFixed(2).padStart(7)}${lat.beta.toFixed(2).padStart(7)}${lat.gamma.toFixed(2).padStart(7)} P 1           1`
    );

    // Atoms
    structure.atoms.forEach((atom, i) => {
        const serial = (i + 1).toString().padStart(5);
        const name = atom.element.padEnd(4);
        const resName = 'MOL';
        const chainId = 'A';
        const resSeq = '1'.padStart(4);

        // Use cartesian coordinates for PDB
        const coords = atom.cartesian || atom.coords;
        const x = coords[0].toFixed(3).padStart(8);
        const y = coords[1].toFixed(3).padStart(8);
        const z = coords[2].toFixed(3).padStart(8);

        const occupancy = '1.00';
        const tempFactor = '0.00';
        const element = atom.element.padStart(2);

        lines.push(
            `ATOM  ${serial} ${name} ${resName} ${chainId}${resSeq}    ${x}${y}${z}  ${occupancy}  ${tempFactor}          ${element}`
        );
    });

    lines.push('END');
    return lines.join('\n');
}

/**
 * Convert MCP structure to XYZ format (simple Cartesian coordinates)
 */
export function structureToXyz(structure: StructureData): string {
    const lines: string[] = [];
    const natoms = structure.atoms.length;
    const formula = structure.metadata?.formula || 'Structure';

    lines.push(natoms.toString());
    lines.push(formula);

    structure.atoms.forEach(atom => {
        const coords = atom.cartesian || atom.coords;
        lines.push(`${atom.element} ${coords[0].toFixed(6)} ${coords[1].toFixed(6)} ${coords[2].toFixed(6)}`);
    });

    return lines.join('\n');
}

/**
 * Generate SMILES from structure (placeholder - would need RDKit integration)
 * For now, returns empty string as this requires actual chemistry library
 */
export function structureToSmiles(_structure: StructureData): string {
    // TODO: Integrate with RDKit or Open Babel for proper conversion
    console.warn('SMILES conversion requires RDKit - returning empty string');
    return '';
}

/**
 * Detect bonds from atom positions based on covalent radii
 */
export function detectBonds(atoms: AtomData[]): Array<[number, number]> {
    const bonds: Array<[number, number]> = [];

    // Covalent radii in Angstroms (approximate)
    const covalentRadii: Record<string, number> = {
        H: 0.31, C: 0.76, N: 0.71, O: 0.66, F: 0.57, P: 1.07, S: 1.05,
        Cl: 1.02, Br: 1.20, I: 1.39, Si: 1.11, Se: 1.20, Te: 1.38,
        B: 0.84, Al: 1.21, Ga: 1.22, In: 1.42, Tl: 1.45,
        Ge: 1.20, Sn: 1.39, Pb: 1.46, As: 1.19, Sb: 1.39, Bi: 1.48,
        Fe: 1.32, Co: 1.26, Ni: 1.24, Cu: 1.32, Zn: 1.22,
        Ru: 1.46, Rh: 1.42, Pd: 1.39, Ag: 1.45, Pt: 1.36, Au: 1.36,
    };

    const tolerance = 0.4; // Bond tolerance

    for (let i = 0; i < atoms.length; i++) {
        for (let j = i + 1; j < atoms.length; j++) {
            const a1 = atoms[i];
            const a2 = atoms[j];

            const c1 = a1.cartesian || a1.coords;
            const c2 = a2.cartesian || a2.coords;

            const dx = c1[0] - c2[0];
            const dy = c1[1] - c2[1];
            const dz = c1[2] - c2[2];
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            const r1 = covalentRadii[a1.element] || 1.5;
            const r2 = covalentRadii[a2.element] || 1.5;
            const maxBondLength = r1 + r2 + tolerance;

            if (distance < maxBondLength && distance > 0.4) {
                bonds.push([i, j]);
            }
        }
    }

    return bonds;
}

/**
 * Calculate center of mass for a structure
 */
export function calculateCenterOfMass(atoms: AtomData[]): [number, number, number] {
    if (atoms.length === 0) return [0, 0, 0];

    let totalX = 0, totalY = 0, totalZ = 0;

    atoms.forEach(atom => {
        const coords = atom.cartesian || atom.coords;
        totalX += coords[0];
        totalY += coords[1];
        totalZ += coords[2];
    });

    const n = atoms.length;
    return [totalX / n, totalY / n, totalZ / n];
}

/**
 * Calculate bounding box for structure
 */
export function calculateBoundingBox(atoms: AtomData[]): { min: [number, number, number]; max: [number, number, number] } {
    if (atoms.length === 0) {
        return { min: [0, 0, 0], max: [0, 0, 0] };
    }

    const coords = atoms.map(a => a.cartesian || a.coords);

    const min: [number, number, number] = [
        Math.min(...coords.map(c => c[0])),
        Math.min(...coords.map(c => c[1])),
        Math.min(...coords.map(c => c[2])),
    ];

    const max: [number, number, number] = [
        Math.max(...coords.map(c => c[0])),
        Math.max(...coords.map(c => c[1])),
        Math.max(...coords.map(c => c[2])),
    ];

    return { min, max };
}
