#!/usr/bin/env python3
"""
Crystal MCP Server - Real World Demonstration
=============================================

This script demonstrates the complete workflow:
1. Natural Language Input → MCP Tool Selection
2. MCP Tool Execution → Crystal Structure Generation
3. Structure Output → Multiple Formats (CIF, POSCAR, XYZ, HTML visualization)

This is a production-ready demonstration of the Crystal MCP Server capabilities.
"""

import json
import sys
import os
import io
import numpy as np
from pathlib import Path
from datetime import datetime

# Add the src/python directory to path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT / "src" / "python"))
sys.path.insert(0, str(PROJECT_ROOT / "src" / "python" / "generators"))

from crystal_generator import generate_crystal
from symmetry_analyzer import analyze_symmetry
from validators import validate_structure

# Import converters
from output_formats.converters import export_cif, export_vasp, export_xyz

# Import visualization helpers
from ase import Atoms
from ase.io import write as ase_write

# Output directory
OUTPUT_DIR = Path(__file__).parent / "real_outputs"
OUTPUT_DIR.mkdir(exist_ok=True)


def print_banner(title: str):
    """Print a styled banner."""
    width = 70
    print("\n" + "=" * width)
    print(f"  {title}")
    print("=" * width)


def print_section(title: str):
    """Print a section header."""
    print(f"\n{'─' * 50}")
    print(f"  {title}")
    print(f"{'─' * 50}")


def dict_to_ase_atoms(structure_dict: dict) -> Atoms:
    """Convert structure dictionary to ASE Atoms object."""
    lattice = structure_dict["lattice"]
    cell = np.array(lattice["matrix"])
    atoms_data = structure_dict["atoms"]

    symbols = [atom["element"] for atom in atoms_data]
    positions = [atom["cartesian"] for atom in atoms_data]

    return Atoms(symbols=symbols, positions=positions, cell=cell, pbc=True)


def generate_html_visualization(structure_dict: dict) -> str:
    """Generate interactive 3Dmol.js HTML visualization."""
    atoms = dict_to_ase_atoms(structure_dict)

    # Convert to XYZ string
    xyz_io = io.StringIO()
    ase_write(xyz_io, atoms, format='xyz')
    xyz_data = xyz_io.getvalue().replace('`', '\\`')

    formula = structure_dict.get('metadata', {}).get('formula', 'Structure')
    space_group = structure_dict.get('space_group', {}).get('symbol', 'Unknown')

    html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{formula} - Crystal Structure</title>
    <script src="https://3Dmol.csb.pitt.edu/build/3Dmol-min.js"></script>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f0f2f5; }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; text-align: center; }}
        .header h1 {{ font-size: 24px; margin-bottom: 5px; }}
        .header p {{ opacity: 0.9; }}
        .container {{ display: flex; height: calc(100vh - 80px); }}
        .viewer {{ flex: 1; background: white; margin: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .sidebar {{ width: 300px; padding: 20px; background: white; margin: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow-y: auto; }}
        .sidebar h3 {{ color: #333; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #667eea; }}
        .property {{ margin-bottom: 12px; }}
        .property label {{ font-size: 12px; color: #666; display: block; margin-bottom: 2px; }}
        .property value {{ font-size: 14px; color: #333; font-weight: 500; }}
        .controls {{ margin-top: 20px; }}
        .btn {{ width: 100%; padding: 10px; margin-bottom: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }}
        .btn-primary {{ background: #667eea; color: white; }}
        .btn-secondary {{ background: #f0f0f0; color: #333; }}
        .btn:hover {{ opacity: 0.9; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{formula}</h1>
        <p>Space Group: {space_group} | Generated by Crystal MCP Server</p>
    </div>
    <div class="container">
        <div id="viewer" class="viewer"></div>
        <div class="sidebar">
            <h3>Crystal Properties</h3>
            <div class="property"><label>Formula</label><value>{formula}</value></div>
            <div class="property"><label>Space Group</label><value>{space_group}</value></div>
            <div class="property"><label>Crystal System</label><value>{structure_dict.get('space_group', {}).get('crystal_system', 'N/A')}</value></div>
            <div class="property"><label>Number of Atoms</label><value>{structure_dict.get('metadata', {}).get('natoms', 'N/A')}</value></div>
            <div class="property"><label>Volume</label><value>{structure_dict.get('lattice', {}).get('volume', 0):.2f} Å³</value></div>
            <div class="property"><label>Density</label><value>{structure_dict.get('metadata', {}).get('density', 0):.3f} g/cm³</value></div>

            <h3>Lattice Parameters</h3>
            <div class="property"><label>a</label><value>{structure_dict.get('lattice', {}).get('a', 0):.4f} Å</value></div>
            <div class="property"><label>b</label><value>{structure_dict.get('lattice', {}).get('b', 0):.4f} Å</value></div>
            <div class="property"><label>c</label><value>{structure_dict.get('lattice', {}).get('c', 0):.4f} Å</value></div>
            <div class="property"><label>α</label><value>{structure_dict.get('lattice', {}).get('alpha', 0):.2f}°</value></div>
            <div class="property"><label>β</label><value>{structure_dict.get('lattice', {}).get('beta', 0):.2f}°</value></div>
            <div class="property"><label>γ</label><value>{structure_dict.get('lattice', {}).get('gamma', 0):.2f}°</value></div>

            <div class="controls">
                <h3>View Controls</h3>
                <button class="btn btn-primary" onclick="resetView()">Reset View</button>
                <button class="btn btn-secondary" onclick="toggleStyle('stick')">Stick Model</button>
                <button class="btn btn-secondary" onclick="toggleStyle('sphere')">Space Filling</button>
                <button class="btn btn-secondary" onclick="toggleStyle('ball')">Ball & Stick</button>
            </div>
        </div>
    </div>
    <script>
        let viewer;
        document.addEventListener('DOMContentLoaded', function() {{
            let element = document.getElementById('viewer');
            let config = {{ backgroundColor: "white" }};
            viewer = $3Dmol.createViewer(element, config);
            let data = `{xyz_data}`;
            viewer.addModel(data, "xyz");
            viewer.setStyle({{}}, {{stick: {{radius: 0.15}}, sphere: {{scale: 0.25}}}});
            viewer.addUnitCell(viewer.getModel());
            viewer.zoomTo();
            viewer.render();
        }});

        function resetView() {{
            viewer.zoomTo();
            viewer.render();
        }}

        function toggleStyle(style) {{
            if (style === 'stick') {{
                viewer.setStyle({{}}, {{stick: {{radius: 0.15}}}});
            }} else if (style === 'sphere') {{
                viewer.setStyle({{}}, {{sphere: {{}}}});
            }} else {{
                viewer.setStyle({{}}, {{stick: {{radius: 0.15}}, sphere: {{scale: 0.25}}}});
            }}
            viewer.render();
        }}
    </script>
</body>
</html>"""
    return html_content


def natural_language_to_mcp_request(query: str) -> dict:
    """
    Simulates how an LLM would parse natural language into MCP tool calls.

    IMPORTANT: The compositions must match valid Wyckoff multiplicities for each space group!
    """
    query_lower = query.lower()

    # Silicon in diamond structure (Fd-3m #227)
    # 8a site has multiplicity 8 - need 8 Si atoms
    if "silicon" in query_lower and "diamond" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Si"] * 8,  # 8a Wyckoff site
                "space_group": 227,
                "seed": 42
            },
            "intent": "Generate silicon in diamond cubic structure (Fd-3m, 8 atoms in 8a site)"
        }

    # NaCl rocksalt structure (Fm-3m #225)
    # 4a site for Na (4 atoms), 4b site for Cl (4 atoms)
    elif "nacl" in query_lower or ("sodium" in query_lower and "chloride" in query_lower):
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Na"] * 4 + ["Cl"] * 4,  # 4a + 4b sites
                "space_group": 225,
                "seed": 42
            },
            "intent": "Generate NaCl in rocksalt structure (Fm-3m, 4+4 atoms)"
        }

    # BaTiO3 perovskite (Pm-3m #221)
    # 1a for Ba, 1b for Ti, 3c for O
    elif "perovskite" in query_lower or "batio3" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Ba", "Ti", "O", "O", "O"],  # 1+1+3 = 5 atoms
                "space_group": 221,
                "seed": 42
            },
            "intent": "Generate BaTiO3 cubic perovskite (Pm-3m)"
        }

    # Graphite (P6_3/mmc #194)
    # 2a site for C (multiplicity 2) + 2b site for C (multiplicity 2)
    elif "graphite" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["C"] * 4,  # 4 C atoms
                "space_group": 194,
                "seed": 42
            },
            "intent": "Generate graphite (P6_3/mmc)"
        }

    # hBN (P6_3/mmc #194)
    # 2a for B, 2b for N
    elif "hbn" in query_lower or "boron nitride" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["B", "B", "N", "N"],  # 2+2 atoms
                "space_group": 194,
                "seed": 42
            },
            "intent": "Generate hexagonal boron nitride (P6_3/mmc)"
        }

    # BCC Iron (Im-3m #229)
    # 2a site has multiplicity 2
    elif "iron" in query_lower and "bcc" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Fe", "Fe"],  # 2a site
                "space_group": 229,
                "seed": 42
            },
            "intent": "Generate BCC iron (Im-3m)"
        }

    # FCC Gold (Fm-3m #225)
    # 4a site has multiplicity 4
    elif "gold" in query_lower or "fcc" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Au"] * 4,  # 4a site
                "space_group": 225,
                "seed": 42
            },
            "intent": "Generate FCC gold (Fm-3m)"
        }

    # Wurtzite ZnO (P6_3mc #186)
    # 2b for Zn, 2b for O
    elif "zinc oxide" in query_lower or "zno" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Zn", "Zn", "O", "O"],  # 2+2 atoms
                "space_group": 186,
                "seed": 42
            },
            "intent": "Generate wurtzite ZnO (P6_3mc)"
        }

    # TiO2 Rutile (P4_2/mnm #136)
    elif "rutile" in query_lower or "tio2" in query_lower:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Ti", "Ti", "O", "O", "O", "O"],  # 2+4 atoms
                "space_group": 136,
                "seed": 42
            },
            "intent": "Generate TiO2 rutile (P4_2/mnm)"
        }

    # Default: Simple cubic structure
    else:
        return {
            "tool": "generate_crystal",
            "params": {
                "composition": ["Cu"],  # Simple 1a site
                "space_group": 221,  # Pm-3m simple cubic
                "seed": 42
            },
            "intent": "Generate simple cubic Cu (Pm-3m)"
        }


def demonstrate_workflow(natural_language_query: str, demo_name: str):
    """Demonstrate the complete workflow for a natural language query."""
    print_banner(f"Demo: {demo_name}")

    # Step 1: Natural Language → MCP Request
    print_section("Step 1: Natural Language Input")
    print(f"  User Query: \"{natural_language_query}\"")

    mcp_request = natural_language_to_mcp_request(natural_language_query)
    print(f"\n  LLM Intent: {mcp_request['intent']}")
    print(f"  Selected Tool: {mcp_request['tool']}")
    print(f"  Parameters:")
    print(f"    composition: {mcp_request['params']['composition']}")
    print(f"    space_group: {mcp_request['params']['space_group']}")

    # Step 2: Execute MCP Tool
    print_section("Step 2: MCP Tool Execution")

    result = generate_crystal(**mcp_request['params'])

    if not result.get('success'):
        error_msg = result.get('error', {}).get('message', 'Unknown error')
        print(f"  ERROR: {error_msg}")
        print(f"  Details: {result.get('error', {}).get('details', {})}")
        return None

    structure = result['structure']
    print(f"  ✓ Structure generated successfully!")
    print(f"    Formula: {structure['metadata']['formula']}")
    print(f"    Atoms: {structure['metadata']['natoms']}")
    print(f"    Space Group: {structure['space_group']['symbol']} (#{structure['space_group']['number']})")
    print(f"    Crystal System: {structure['space_group']['crystal_system']}")
    print(f"    Volume: {structure['lattice']['volume']:.2f} Å³")

    # Step 3: Analyze Symmetry
    print_section("Step 3: Symmetry Analysis")

    symmetry = analyze_symmetry(structure)
    if symmetry.get('success'):
        spg = symmetry['space_group']
        sym_ops = symmetry.get('symmetry_operations', {})
        print(f"  Space Group: {spg['symbol']} (#{spg['number']})")
        print(f"  Point Group: {spg['point_group']}")
        print(f"  Crystal System: {spg['crystal_system']}")
        print(f"  Symmetry Operations: {sym_ops.get('n_operations', 'N/A')}")
        if symmetry.get('wyckoff_positions'):
            print(f"  Wyckoff Positions: {len(symmetry['wyckoff_positions'])} unique sites")

    # Step 4: Validate Structure
    print_section("Step 4: Structure Validation")

    validation = validate_structure(structure)
    if validation.get('success'):
        status = "✓ VALID" if validation['valid'] else "✗ INVALID"
        print(f"  Status: {status}")
        if validation.get('errors'):
            for error in validation['errors'][:3]:
                print(f"    - {error}")
        if validation.get('warnings'):
            for warning in validation['warnings'][:3]:
                print(f"    ⚠ {warning}")
        if validation.get('metrics'):
            metrics = validation['metrics']
            print(f"  Min Distance: {metrics.get('min_distance', 0):.3f} Å")
            print(f"  Density: {metrics.get('density', 0):.3f} g/cm³")

    # Step 5: Export to Multiple Formats
    print_section("Step 5: Export Formats")

    output_base = OUTPUT_DIR / demo_name.lower().replace(" ", "_")

    # Export CIF
    cif_result = export_cif(structure)
    if cif_result.get('success'):
        cif_file = f"{output_base}.cif"
        with open(cif_file, 'w') as f:
            f.write(cif_result['content'])
        print(f"  ✓ CIF:    {cif_file}")

    # Export POSCAR (VASP)
    vasp_result = export_vasp(structure)
    if vasp_result.get('success'):
        vasp_file = f"{output_base}.vasp"
        with open(vasp_file, 'w') as f:
            f.write(vasp_result['content'])
        print(f"  ✓ POSCAR: {vasp_file}")

    # Export XYZ
    xyz_result = export_xyz(structure)
    if xyz_result.get('success'):
        xyz_file = f"{output_base}.xyz"
        with open(xyz_file, 'w') as f:
            f.write(xyz_result['content'])
        print(f"  ✓ XYZ:    {xyz_file}")

    # Export complete JSON
    json_file = f"{output_base}_complete.json"
    with open(json_file, 'w') as f:
        json.dump({
            "query": natural_language_query,
            "mcp_request": mcp_request,
            "structure": structure,
            "symmetry": {
                "space_group": symmetry.get('space_group'),
                "wyckoff_positions": symmetry.get('wyckoff_positions'),
                "n_operations": symmetry.get('symmetry_operations', {}).get('n_operations')
            } if symmetry.get('success') else None,
            "validation": {
                "valid": validation.get('valid'),
                "errors": validation.get('errors'),
                "warnings": validation.get('warnings'),
                "metrics": validation.get('metrics')
            } if validation.get('success') else None,
            "timestamp": datetime.now().isoformat()
        }, f, indent=2)
    print(f"  ✓ JSON:   {json_file}")

    # Step 6: Generate Visualization
    print_section("Step 6: Interactive Visualization")

    html_content = generate_html_visualization(structure)
    html_file = f"{output_base}_viz.html"
    with open(html_file, 'w') as f:
        f.write(html_content)
    print(f"  ✓ HTML:   {html_file}")
    print(f"    → Open in browser for 3D interactive visualization!")

    print(f"\n  All outputs saved to: {OUTPUT_DIR}/")

    return result


def main():
    """Main demonstration showing multiple use cases."""

    print_banner("Crystal MCP Server - Real World Demonstration")
    print(f"""
    This demonstration shows the complete workflow:

    1. Natural Language Input (simulating LLM parsing)
    2. MCP Tool Selection & Execution
    3. Crystal Structure Generation (PyXtal backend)
    4. Symmetry Analysis (Spglib)
    5. Structure Validation
    6. Multi-Format Export (CIF, POSCAR, XYZ, JSON)
    7. Interactive 3D Visualization (3Dmol.js)

    Output Directory: {OUTPUT_DIR}
    """)

    # Define test cases with natural language queries
    # Note: Compositions are validated by PyXtal against space group Wyckoff positions
    test_cases = [
        ("Generate a silicon crystal with diamond cubic structure", "Silicon_Diamond"),
        ("Create a NaCl rocksalt structure for ionic solid study", "NaCl_Rocksalt"),
        ("Generate BaTiO3 perovskite for ferroelectric applications", "BaTiO3_Perovskite"),
        ("Create a layered graphite carbon structure", "Graphite"),
        ("Generate hexagonal boron nitride (hBN) for 2D applications", "hBN"),
        ("Create iron in BCC structure for magnetic studies", "Iron_BCC"),
        ("Generate wurtzite ZnO for semiconductor applications", "ZnO_Wurtzite"),
        ("Create TiO2 rutile structure for photocatalysis", "TiO2_Rutile"),
    ]

    successful = 0
    failed = 0
    results = []

    for query, name in test_cases:
        result = demonstrate_workflow(query, name)
        if result and result.get('success'):
            successful += 1
            results.append((name, result))
        else:
            failed += 1

    # Summary
    print_banner("Demonstration Complete")
    print(f"""
    Results Summary:
    ─────────────────────────────
    Successful: {successful}/{len(test_cases)}
    Failed:     {failed}/{len(test_cases)}

    Output Files Generated:
    ─────────────────────────────""")

    for f in sorted(OUTPUT_DIR.iterdir()):
        size = f.stat().st_size
        print(f"    {f.name:45} ({size:,} bytes)")

    print(f"""
    ─────────────────────────────

    To view the interactive 3D visualizations, open any *_viz.html file
    in a web browser.

    These output files can be directly used with:
    ─────────────────────────────
    • VASP           → *.vasp (POSCAR files)
    • Quantum ESPRESSO → import CIF or convert POSCAR
    • LAMMPS         → convert via atomsk or ase
    • VESTA          → *.cif for visualization
    • Materials Studio → *.cif
    • Avogadro       → *.xyz
    • OVITO          → *.xyz, *.vasp
    ─────────────────────────────
    """)


if __name__ == "__main__":
    main()
