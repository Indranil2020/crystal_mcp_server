"""
output_formats/converters.py - Format Converters

Converts structures to various DFT/MD input formats:
- VASP POSCAR
- Quantum ESPRESSO
- LAMMPS data
- XYZ, CIF, PDB
"""

from typing import Dict, Any, List, Optional, Union
import importlib.util
import numpy as np

Structure = None
if importlib.util.find_spec("pymatgen.core") is not None:
    from pymatgen.core import Structure


# Supported output formats
SUPPORTED_FORMATS = {
    "vasp": {"extension": ".vasp", "description": "VASP POSCAR format"},
    "qe": {"extension": ".pwi", "description": "Quantum ESPRESSO pw.x input"},
    "lammps": {"extension": ".data", "description": "LAMMPS data file"},
    "xyz": {"extension": ".xyz", "description": "XYZ coordinate file"},
    "cif": {"extension": ".cif", "description": "Crystallographic Information File"},
    "pdb": {"extension": ".pdb", "description": "Protein Data Bank format"},
    "extxyz": {"extension": ".extxyz", "description": "Extended XYZ with lattice"},
    "xsf": {"extension": ".xsf", "description": "XCrySDen Structure Format"},
}


def _normalize_structure(structure: Union[Dict, Any]) -> Dict[str, Any]:
    """Convert pymatgen Structure to dict if needed."""
    if Structure and isinstance(structure, Structure):
        return {
            "atoms": [{"element": str(s.specie), "coords": list(s.frac_coords), "cartesian": list(s.coords)} for s in structure],
            "lattice": {
                "a": structure.lattice.a, "b": structure.lattice.b, "c": structure.lattice.c,
                "alpha": structure.lattice.alpha, "beta": structure.lattice.beta, "gamma": structure.lattice.gamma,
                "matrix": structure.lattice.matrix.tolist()
            }
        }
    return structure


def _get_lattice_matrix(lattice_info: Dict[str, Any]) -> np.ndarray:
    """
    Get or compute the 3x3 lattice matrix from lattice info.
    Critical for proper coordinate transformations in non-orthogonal cells.
    """
    # Use matrix directly if available
    if "matrix" in lattice_info and lattice_info["matrix"] is not None:
        return np.array(lattice_info["matrix"])

    # Otherwise compute from parameters
    a = lattice_info.get("a", 5.0)
    b = lattice_info.get("b", a)
    c = lattice_info.get("c", a)
    alpha = lattice_info.get("alpha", 90.0)
    beta = lattice_info.get("beta", 90.0)
    gamma = lattice_info.get("gamma", 90.0)

    # Convert to radians
    alpha_r = np.radians(alpha)
    beta_r = np.radians(beta)
    gamma_r = np.radians(gamma)

    cos_alpha = np.cos(alpha_r)
    cos_beta = np.cos(beta_r)
    cos_gamma = np.cos(gamma_r)
    sin_gamma = np.sin(gamma_r)

    # Standard crystallographic convention
    ax, ay, az = a, 0.0, 0.0
    bx = b * cos_gamma
    by = b * sin_gamma
    bz = 0.0
    cx = c * cos_beta
    cy = c * (cos_alpha - cos_beta * cos_gamma) / sin_gamma if sin_gamma > 1e-10 else 0.0
    cz_sq = 1 - cos_alpha**2 - cos_beta**2 - cos_gamma**2 + 2 * cos_alpha * cos_beta * cos_gamma
    cz = c * np.sqrt(max(0, cz_sq)) / sin_gamma if sin_gamma > 1e-10 else c

    return np.array([
        [ax, ay, az],
        [bx, by, bz],
        [cx, cy, cz]
    ])


def _frac_to_cart(frac_coords: List[float], lattice_info: Dict[str, Any]) -> List[float]:
    """
    Convert fractional coordinates to Cartesian using proper lattice matrix.
    Essential for non-orthogonal (triclinic, monoclinic) cells.
    """
    matrix = _get_lattice_matrix(lattice_info)
    frac = np.array(frac_coords)
    # cart = matrix.T @ frac for row-major lattice vectors
    cart = matrix.T @ frac
    return cart.tolist()


def export_vasp(
    structure: Union[Dict[str, Any], Any],
    direct: bool = True,
    comment: str = "Generated by Crystal MCP Server"
) -> Dict[str, Any]:
    """
    Export structure to VASP POSCAR format.
    """
    structure = _normalize_structure(structure)
    atoms = structure.get("structure", structure).get("atoms", [])
    lattice_info = structure.get("structure", structure).get("lattice", {})
    
    if not atoms:
        return {"success": False, "error": {"code": "NO_ATOMS", "message": "No atoms"}}
    
    # Get lattice matrix
    if "matrix" in lattice_info:
        matrix = lattice_info["matrix"]
    else:
        a = lattice_info.get("a", 5.0)
        b = lattice_info.get("b", a)
        c = lattice_info.get("c", a)
        matrix = [[a, 0, 0], [0, b, 0], [0, 0, c]]
    
    # Group by element
    elements = []
    counts = []
    grouped_coords = []
    
    elem_order = {}
    for atom in atoms:
        elem = atom.get("element", "X")
        if elem not in elem_order:
            elem_order[elem] = len(elem_order)
            elements.append(elem)
            counts.append(0)
            grouped_coords.append([])
        
        idx = elem_order[elem]
        counts[idx] += 1
        grouped_coords[idx].append(atom.get("coords", [0, 0, 0]))
    
    # Build POSCAR
    lines = []
    lines.append(comment)
    lines.append("1.0")  # Scaling factor
    
    for row in matrix:
        lines.append(f"  {row[0]:15.10f}  {row[1]:15.10f}  {row[2]:15.10f}")
    
    lines.append("  " + "  ".join(elements))
    lines.append("  " + "  ".join(str(c) for c in counts))
    
    if direct:
        lines.append("Direct")
    else:
        lines.append("Cartesian")
    
    for elem_coords in grouped_coords:
        for coord in elem_coords:
            lines.append(f"  {coord[0]:15.10f}  {coord[1]:15.10f}  {coord[2]:15.10f}")
    
    poscar_content = "\n".join(lines)
    
    return {
        "success": True,
        "format": "vasp",
        "content": poscar_content,
        "elements": elements,
        "counts": counts,
        "n_atoms": sum(counts)
    }


def export_quantum_espresso(
    structure: Dict[str, Any],
    pseudopot_dir: str = "./pseudo",
    ecutwfc: float = 50.0,
    ecutrho: float = 400.0
) -> Dict[str, Any]:
    """
    Export structure to Quantum ESPRESSO pw.x input format.
    
    Args:
        structure: Structure dictionary
        pseudopot_dir: Pseudopotential directory
        ecutwfc: Wavefunction cutoff (Ry)
        ecutrho: Charge density cutoff (Ry)
    
    Returns:
        QE input string
    """
    structure = _normalize_structure(structure)
    atoms = structure.get("structure", structure).get("atoms", [])
    lattice_info = structure.get("structure", structure).get("lattice", {})
    
    if not atoms:
        return {"success": False, "error": {"code": "NO_ATOMS", "message": "No atoms"}}
    
    # Get lattice parameters
    a = lattice_info.get("a", 5.0)
    b = lattice_info.get("b", a)
    c = lattice_info.get("c", a)
    
    # Unique elements
    elements = list(set(atom.get("element", "X") for atom in atoms))
    
    # Build input
    lines = []
    
    lines.append("&CONTROL")
    lines.append("  calculation = 'scf'")
    lines.append(f"  pseudo_dir = '{pseudopot_dir}'")
    lines.append("  outdir = './tmp'")
    lines.append("/")
    
    lines.append("&SYSTEM")
    lines.append(f"  ibrav = 0")
    lines.append(f"  nat = {len(atoms)}")
    lines.append(f"  ntyp = {len(elements)}")
    lines.append(f"  ecutwfc = {ecutwfc}")
    lines.append(f"  ecutrho = {ecutrho}")
    lines.append("/")
    
    lines.append("&ELECTRONS")
    lines.append("  mixing_beta = 0.3")
    lines.append("/")
    
    lines.append("")
    lines.append("ATOMIC_SPECIES")
    for elem in elements:
        mass = {"H": 1.008, "C": 12.01, "N": 14.01, "O": 16.00, "Fe": 55.85, "Si": 28.09}.get(elem, 50.0)
        lines.append(f"  {elem}  {mass:.4f}  {elem}.UPF")
    
    lines.append("")
    lines.append("CELL_PARAMETERS angstrom")

    # Use full lattice matrix if available (critical for non-orthogonal cells)
    lattice_matrix = lattice_info.get("matrix")
    if lattice_matrix is not None:
        # Use actual lattice vectors for triclinic/monoclinic/etc.
        for vec in lattice_matrix:
            lines.append(f"  {vec[0]:.10f}  {vec[1]:.10f}  {vec[2]:.10f}")
    else:
        # Fallback to orthogonal approximation (only valid for cubic/orthorhombic)
        alpha = lattice_info.get("alpha", 90.0)
        beta = lattice_info.get("beta", 90.0)
        gamma = lattice_info.get("gamma", 90.0)

        if abs(alpha - 90) > 0.01 or abs(beta - 90) > 0.01 or abs(gamma - 90) > 0.01:
            # Non-orthogonal cell without matrix - compute from parameters
            import math
            cos_alpha = math.cos(math.radians(alpha))
            cos_beta = math.cos(math.radians(beta))
            cos_gamma = math.cos(math.radians(gamma))
            sin_gamma = math.sin(math.radians(gamma))

            # Standard crystallographic convention for lattice vectors
            ax, ay, az = a, 0.0, 0.0
            bx = b * cos_gamma
            by = b * sin_gamma
            bz = 0.0
            cx = c * cos_beta
            cy = c * (cos_alpha - cos_beta * cos_gamma) / sin_gamma
            cz = c * math.sqrt(1 - cos_alpha**2 - cos_beta**2 - cos_gamma**2 +
                              2 * cos_alpha * cos_beta * cos_gamma) / sin_gamma

            lines.append(f"  {ax:.10f}  {ay:.10f}  {az:.10f}")
            lines.append(f"  {bx:.10f}  {by:.10f}  {bz:.10f}")
            lines.append(f"  {cx:.10f}  {cy:.10f}  {cz:.10f}")
        else:
            # Orthogonal cell
            lines.append(f"  {a:.10f}  0.0000000000  0.0000000000")
            lines.append(f"  0.0000000000  {b:.10f}  0.0000000000")
            lines.append(f"  0.0000000000  0.0000000000  {c:.10f}")
    
    lines.append("")
    lines.append("ATOMIC_POSITIONS crystal")
    for atom in atoms:
        elem = atom.get("element", "X")
        coord = atom.get("coords", [0, 0, 0])
        lines.append(f"  {elem}  {coord[0]:.10f}  {coord[1]:.10f}  {coord[2]:.10f}")
    
    lines.append("")
    lines.append("K_POINTS automatic")
    lines.append("  4 4 4  0 0 0")
    
    content = "\n".join(lines)
    
    return {
        "success": True,
        "format": "quantum_espresso",
        "content": content,
        "n_atoms": len(atoms),
        "n_types": len(elements)
    }


def export_lammps(
    structure: Dict[str, Any],
    atom_style: str = "atomic",
    units: str = "metal"
) -> Dict[str, Any]:
    """
    Export structure to LAMMPS data file format.
    
    Args:
        structure: Structure dictionary
        atom_style: LAMMPS atom style
        units: LAMMPS unit system
    
    Returns:
        LAMMPS data file string
    """
    structure = _normalize_structure(structure)
    atoms = structure.get("structure", structure).get("atoms", [])
    lattice_info = structure.get("structure", structure).get("lattice", {})
    
    if not atoms:
        return {"success": False, "error": {"code": "NO_ATOMS", "message": "No atoms"}}
    
    a = lattice_info.get("a", 10.0)
    b = lattice_info.get("b", a)
    c = lattice_info.get("c", a)
    
    # Element types
    elements = list(set(atom.get("element", "X") for atom in atoms))
    elem_to_type = {e: i+1 for i, e in enumerate(elements)}
    
    lines = []
    lines.append("# LAMMPS data file - Generated by Crystal MCP Server")
    lines.append("")
    lines.append(f"{len(atoms)} atoms")
    lines.append(f"{len(elements)} atom types")
    lines.append("")
    lines.append(f"0.0 {a:.6f} xlo xhi")
    lines.append(f"0.0 {b:.6f} ylo yhi")
    lines.append(f"0.0 {c:.6f} zlo zhi")
    lines.append("")
    lines.append("Masses")
    lines.append("")
    
    for elem in elements:
        mass = {"H": 1.008, "C": 12.01, "N": 14.01, "O": 16.00, "Fe": 55.85, "Si": 28.09, "Cu": 63.55, "Au": 197.0}.get(elem, 50.0)
        lines.append(f"  {elem_to_type[elem]} {mass:.4f}  # {elem}")
    
    lines.append("")
    lines.append("Atoms")
    lines.append("")

    # Get lattice matrix for proper fractional to Cartesian conversion
    lattice_matrix = lattice_info.get("matrix")

    for i, atom in enumerate(atoms):
        elem = atom.get("element", "X")
        coord = atom.get("coords", [0, 0, 0])

        # Use cartesian coords if available, otherwise convert properly
        if "cartesian" in atom:
            x, y, z = atom["cartesian"]
        elif lattice_matrix is not None:
            # Proper fractional to Cartesian: cart = matrix.T @ frac (row-major convention)
            matrix = np.array(lattice_matrix)
            frac = np.array(coord)
            cart = matrix.T @ frac
            x, y, z = cart
        else:
            # Fallback - compute matrix from parameters for non-orthogonal cells
            alpha = lattice_info.get("alpha", 90.0)
            beta = lattice_info.get("beta", 90.0)
            gamma = lattice_info.get("gamma", 90.0)

            if abs(alpha - 90) > 0.01 or abs(beta - 90) > 0.01 or abs(gamma - 90) > 0.01:
                import math
                cos_alpha = math.cos(math.radians(alpha))
                cos_beta = math.cos(math.radians(beta))
                cos_gamma = math.cos(math.radians(gamma))
                sin_gamma = math.sin(math.radians(gamma))

                # Lattice vectors
                ax, ay, az = a, 0.0, 0.0
                bx = b * cos_gamma
                by = b * sin_gamma
                bz = 0.0
                cx = c * cos_beta
                cy = c * (cos_alpha - cos_beta * cos_gamma) / sin_gamma
                cz = c * math.sqrt(max(0, 1 - cos_alpha**2 - cos_beta**2 - cos_gamma**2 +
                                  2 * cos_alpha * cos_beta * cos_gamma)) / sin_gamma

                # Fractional to Cartesian
                x = coord[0] * ax + coord[1] * bx + coord[2] * cx
                y = coord[0] * ay + coord[1] * by + coord[2] * cy
                z = coord[0] * az + coord[1] * bz + coord[2] * cz
            else:
                # Orthogonal cell
                x = coord[0] * a
                y = coord[1] * b
                z = coord[2] * c

        lines.append(f"  {i+1} {elem_to_type[elem]} {x:.6f} {y:.6f} {z:.6f}")
    
    content = "\n".join(lines)
    
    return {
        "success": True,
        "format": "lammps",
        "content": content,
        "n_atoms": len(atoms),
        "atom_types": elem_to_type
    }


def export_xyz(
    structure: Dict[str, Any],
    comment: str = "Generated by Crystal MCP Server"
) -> Dict[str, Any]:
    """
    Export structure to XYZ format.

    Args:
        structure: Structure dictionary
        comment: Comment line

    Returns:
        XYZ string
    """
    structure = _normalize_structure(structure)
    atoms = structure.get("structure", structure).get("atoms", [])
    lattice_info = structure.get("structure", structure).get("lattice", {})

    if not atoms:
        return {"success": False, "error": {"code": "NO_ATOMS", "message": "No atoms"}}

    lines = []
    lines.append(str(len(atoms)))
    lines.append(comment)

    for atom in atoms:
        elem = atom.get("element", "X")

        # Prefer Cartesian coords if available, otherwise convert from fractional
        if "cartesian" in atom and atom["cartesian"]:
            x, y, z = atom["cartesian"]
        else:
            coord = atom.get("coords", [0, 0, 0])
            # Use proper matrix conversion for non-orthogonal cells
            cart = _frac_to_cart(coord, lattice_info)
            x, y, z = cart

        lines.append(f"{elem}  {x:.6f}  {y:.6f}  {z:.6f}")
    
    content = "\n".join(lines)
    
    return {
        "success": True,
        "format": "xyz",
        "content": content,
        "n_atoms": len(atoms)
    }


def export_cif(
    structure: Dict[str, Any],
    data_name: str = "structure"
) -> Dict[str, Any]:
    """
    Export structure to CIF format.
    
    Args:
        structure: Structure dictionary
        data_name: CIF data block name
    
    Returns:
        CIF string
    """
    structure = _normalize_structure(structure)
    atoms = structure.get("structure", structure).get("atoms", [])
    lattice_info = structure.get("structure", structure).get("lattice", {})
    
    if not atoms:
        return {"success": False, "error": {"code": "NO_ATOMS", "message": "No atoms"}}
    
    a = lattice_info.get("a", 5.0)
    b = lattice_info.get("b", a)
    c = lattice_info.get("c", a)
    alpha = lattice_info.get("alpha", 90.0)
    beta = lattice_info.get("beta", 90.0)
    gamma = lattice_info.get("gamma", 90.0)
    
    lines = []
    lines.append(f"data_{data_name}")
    lines.append("")
    lines.append(f"_cell_length_a    {a:.5f}")
    lines.append(f"_cell_length_b    {b:.5f}")
    lines.append(f"_cell_length_c    {c:.5f}")
    lines.append(f"_cell_angle_alpha {alpha:.3f}")
    lines.append(f"_cell_angle_beta  {beta:.3f}")
    lines.append(f"_cell_angle_gamma {gamma:.3f}")
    lines.append("")
    lines.append("_symmetry_space_group_name_H-M  'P 1'")
    lines.append("_symmetry_Int_Tables_number     1")
    lines.append("")
    lines.append("loop_")
    lines.append("_atom_site_label")
    lines.append("_atom_site_type_symbol")
    lines.append("_atom_site_fract_x")
    lines.append("_atom_site_fract_y")
    lines.append("_atom_site_fract_z")
    
    for i, atom in enumerate(atoms):
        elem = atom.get("element", "X")
        coord = atom.get("coords", [0, 0, 0])
        lines.append(f"  {elem}{i+1}  {elem}  {coord[0]:.6f}  {coord[1]:.6f}  {coord[2]:.6f}")
    
    content = "\n".join(lines)
    
    return {
        "success": True,
        "format": "cif",
        "content": content,
        "n_atoms": len(atoms)
    }


def export_pdb(
    structure: Dict[str, Any],
    title: str = "Generated structure"
) -> Dict[str, Any]:
    """
    Export structure to PDB format.
    
    Args:
        structure: Structure dictionary
        title: PDB title
    
    Returns:
        PDB string
    """
    structure = _normalize_structure(structure)
    atoms = structure.get("structure", structure).get("atoms", [])
    lattice_info = structure.get("structure", structure).get("lattice", {})
    
    if not atoms:
        return {"success": False, "error": {"code": "NO_ATOMS", "message": "No atoms"}}
    
    a = lattice_info.get("a", 10.0)
    b = lattice_info.get("b", a)
    c = lattice_info.get("c", a)
    
    lines = []
    lines.append(f"TITLE     {title}")
    lines.append(f"CRYST1{a:9.3f}{b:9.3f}{c:9.3f} 90.00 90.00 90.00 P 1           1")
    
    for i, atom in enumerate(atoms):
        elem = atom.get("element", "X")
        coord = atom.get("coords", [0, 0, 0])
        
        # Convert to Cartesian
        x = coord[0] * a
        y = coord[1] * b
        z = coord[2] * c
        
        lines.append(f"ATOM  {i+1:5d}  {elem:<2s}  MOL     1    {x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00          {elem:>2s}")
    
    lines.append("END")
    
    content = "\n".join(lines)
    
    return {
        "success": True,
        "format": "pdb",
        "content": content,
        "n_atoms": len(atoms)
    }
